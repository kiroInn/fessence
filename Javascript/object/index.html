<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Object Learn</title>
</head>

<body>
    <script>
        // 对象类Object 面向对象编程的基础

        // Create 构造函数Object
        var person1 = new Object();
        person1.owner = 'teahcerWang';
        person1.age = 27;
        person1.introCount = 0;
        person1.isMale = true;
        person1.intro = function () {
            console.log('我是' + this.owner +
                '年龄' + this.age +
                '是我第' + this.introCount++ + '为大家介绍');
        };

        // Create 字面量表示
        // var person2 = {
        //     owner: "teacherZhang",
        //     age: 27,
        //     isMale: true,
        //     introCount: 0,
        //     intro: function () {
        //         console.log('我是' + this.owner +
        //             '年龄' + this.age +
        //             '是我第' + this.introCount++ + '为大家介绍');
        //     }
        // };
        // delete person1.age;
        // person2.isMale;
        // // 通过自定义构造函数
        // function Phone(brand, price) {
        //     var that = this;
        //     that.brand = brand;
        //     that.price = price;
        //     return that;
        // }
        //
        // var miPhone = new Phone();
        // miPhone.owner = 'xxx';
        // miPhone.play = function () { }
        // the new keywords
        // 1 create new object simply object;
        // 2 current scope varibale initialaztion linked this;
        // 3 return this
        // java 
        // class Phone{
        //     String brand;
        //     long price;
        //     Phone(String brand, long price){
        //         this.brand = brand;
        //         this.price = price;
        //     }

        //     void play(){}
        // }

        // class Test{
        //     mian(){
        //         Phone miPhone = new Phone('小米', 1999);
        //         miPhone.brand;
        //         miPhone.play()
        //     }
        // }


        // var test = {
        //     number: function getNumber() {
        //         return 10
        //     }
        // }
        // console.log(test.number());
        // console.log(test['number']());

        // leftxxx property owner
        //  right xxx property value

        // 电脑 对象
        // (property) brand  screenSize  standByTime 
        // （method）  watching  coding  playing    

        // // watching: function ( ) {
        // //     console.log( compute.brand );
        // //     console.log( this.brand );
        // // }
        //
        // //  js 中 this  __proto__?
        // // 引用类型的出现就是解决多个基本类型 一起使用的场景
        // // 面向对象编程的思想
        // // 比较灵活
        //
        // var obj = new Object();
        // obj.owner = 'obj owner';
        // obj.label = 'obj label';
        // obj.toString = function () {
        //     console.log('owner: ' + this.owner + ' label: ' + this.label);
        // };
        // // console.log(obj);
        //
        // // 自己实现的Looger
        // function logger() {
        //     for(var i = 0; i <arguments.length ; i++ ){
        //         var node = arguments[i];
        //         if( typeof(node) === 'object' ){
        //             for(var key in node){
        //                 console.log(node[key]);
        //             }
        //         }else{
        //             console.log(node);
        //         }
        //     }
        // }
        // logger('string', 128);
        // logger(128);
        // logger(true);
        // logger(obj);
        //
        // console.log(obj.owner);
        // console.log(obj.label);
        // console.log(obj.toString());
        // console.log(obj.hasOwnProperty);
        // console.log(obj.isNotMyProperty);
        // console.log(obj);

        // console.log('string');
        // console.log(new String('string').toString());
        // console.log(1);
        // console.log(new Number(1).toString());
        // console.log(true);
        // console.log(new Boolean(true).toString());

        // __proto__  真是的一个对象house 通过链式关系 解决我们 使用 对象的 属性 跟 方法...
        // 帮我们解决了继承关系的一个属性
        // prototype  也是一个对象 它场用来去做__proto__的产生  当我们去创建一个对象的时候 new
        // function MyString(string){
        //     this.string = string;
        //     this.slicer = function (index) {
        //         // 做的事情是拆分字符串
        //         // return '只留下我';
        //         return this.string.slice(index);
        //     }
        // }
        // var initialString  = '我是需要处理的字符串: 只留下我';
        // var string = new MyString(initialString);
        // console.log(string.slicer(initialString.indexOf(' ')));


        // this 很特殊 因为只有在执行时 this才能确定
        // this 的判断很简单 查找执行方法前dot(.)的对象
        // 如果没有发现dot(.) this就是global window
        // 我们可以同过 Function.apply || Function.call 去改变执行中的this 执行的上下文
        // 此对象就是this

        // window.owner = owner
        // var owner = '我是需要处理的字符串: 只留下我(全局的我)';
        // var initialString  = '我是需要处理的字符串: 只留下我(myString)';
        // var myString  = {
        //     owner: initialString,
        //     slicer: function(index){
        //         return this.owner.slice(index);
        //     }
        // };
        //
        // var myThis = {
        //     owner: '我是需要处理的字符串: 只留下我(my this)'
        // };
        // var echoThis = {
        //     owner: '我是需要处理的字符串: 只留下我(echo this)'
        // }

        // console.log(myString.slicer(13));  //只留下我(myString)'
        // console.log(myString.slicer.call(this, 13)); // 只留下我(全局的我)'
        // console.log(myString.slicer.call(myThis, 13)); //只留下我(my this)'
        // console.log(myString.slicer.apply(echoThis, [13])); //只留下我(echo this)'
        //
        //
        // var slicer = function(index){
        //     console.log(this === window);
        //     // var owner = '我是需要处理的字符串: 只留下我(全局的我)';
        //     // return 只留下我(全局的我)'
        //     return this.owner.slice(index);
        // }
        //
        // console.log(slicer(13));

        // function MyString(string){
        //     this.string = string;
        //     this.slicer = function (index) {
        //         // 做的事情是拆分字符串
        //         // return '只留下我';
        //         console.log(this);
        //         return this.string.slice(index);
        //     }
        // }
        // var initialString  = '我是需要处理的字符串: 只留下我';
        // var string = new MyString(initialString);
        // console.log(string.slicer(initialString.indexOf(' ')));

        function MyObject(age) {
            this.age = age;
        }

        MyObject.construct = function () {
            console.log('myconstrut');
            var o = {}, Constructor = MyObject;
            o.__proto__ = Constructor.prototype;
            // FF 支持用户引用内部属性 [[Prototype]]
            Constructor.apply(o, arguments);
            return o;
        };

        var obj1 = new MyObject(10);
        var obj2 = MyObject.construct(10);
        // alert(obj2 instanceof MyObject);// true

        var car = {};
        Object.defineProperty(car, 'brand', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: '保时捷'
        })
        Object.defineProperties(car, {
            name: {
                writable: true
            }
        })

        //工厂模式
        function createPerson(name, age, job) {
            var o = new Object();
            o.owner = name;
            o.age = age;
            o.job = job;
            o.sayName = function () {
                alert(this.owner);
            };
            return o;
        }
        var person1 = createPerson("Nicholas", 29, "Software Engineer");
        var person2 = createPerson("Greg", 27, "Doctor");
        //构造函数
        function Person(name, age, job) {
            this.owner = name;
            this.age = age;
            this.job = job;
            this.sayName = function () {
                alert(this.owner);
            };
        }
        var person1 = new Person("Nicholas", 29, "Software Engineer");
        var person2 = new Person("Greg", 27, "Doctor");

        // 当作构造函数使用
        var person = new Person("Nicholas", 29, "Software Engineer");
        person.sayName(); //"Nicholas"
        // 作为普通函数调用
        Person("Greg", 27, "Doctor"); // 添加到window
        window.sayName(); //"Greg"
        // 在另一个对象的作用域中调用
        var o = new Object();
        Person.call(o, "Kristen", 25, "Nurse");
        o.sayName(); //"Kristen"


        function Person() {
        }
        Person.prototype.owner = "Nicholas";
        Person.prototype.age = 29;
        Person.prototype.job = "Software Engineer";
        Person.prototype.sayName = function () {
            alert(this.owner);
        };
        var person1 = new Person();
        person1.sayName(); //"Nicholas"
        var person2 = new Person();
        person2.sayName(); //"Nicholas"
        alert(person1.sayName == person2.sayName); //true


        // BOM
        // 挑战一
        setTimeout(function () {
            console.log("1");
        }, 0)
        console.log("2");   // ???// 挑战二
        for (var i = 0; i < 5; i++) {
            setTimeout(function () {
                console.log(i);     // ???
            }, 0)
        };// 挑战三
        var a = 1;
        var obj = {
            a: 2,
            b: function () {
                setTimeout(function () {
                    console.log(this.a);
                }, 0)
            }
        }
        obj.b();    // ???// 挑战四
        var a = 1;
        var obj = {
            a: 2,
            b: function () {
                setTimeout(function () {
                    console.log(this.a);
                }.call(this), 0);
            }
        }
        obj.b();    // ???

    </script>
</body>

</html>